//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into Track.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using Storage;


namespace MusicPlayer  {


  public partial class Track: IStorageItemGeneric<Track> {

    #region Properties
    //      ----------

    /// <summary>
    /// Unique identifier for Track. Gets set once Track gets added to DC.Data.
    /// </summary>
    public int Key { get; private set; }
    internal static void SetKey(IStorageItem track, int key, bool _) {
      ((Track)track).Key = key;
    }


    public string FileName { get; }


    public string FullFileName { get; }


    public string? Title { get; private set; }


    /// <summary>
    /// Stores less than 24 hours with second precision.
    ///  </summary>
    public TimeSpan? Duration { get; }


    public string? Album { get; private set; }


    public int? AlbumTrack { get; private set; }


    public string? Artists { get; private set; }


    public string? Composers { get; private set; }


    public string? Genres { get; private set; }


    public string? Publisher { get; private set; }


    public int? Year { get; private set; }


    public int? Weight { get; private set; }


    public int? Volume { get; private set; }


    public int? SkipStart { get; private set; }


    public int? SkipEnd { get; private set; }


    public string TitleArtists { get; private set; }


    /// <summary>
    /// Headers written to first line in CSV file
    /// </summary>
    internal static readonly string[] Headers = {
      "Key", 
      "FileName", 
      "FullFileName", 
      "Title", 
      "Duration", 
      "Album", 
      "AlbumTrack", 
      "Artists", 
      "Composers", 
      "Genres", 
      "Publisher", 
      "Year", 
      "Weight", 
      "Volume", 
      "SkipStart", 
      "SkipEnd", 
      "TitleArtists"
    };


    /// <summary>
    /// None existing Track
    /// </summary>
    internal static Track NoTrack = new Track("NoFileName", "NoFullFileName", null, null, null, null, null, null, null, null, null, null, null, null, null, "NoTitleArtists", isStoring: false);
    #endregion


    #region Events
    //      ------

    /// <summary>
    /// Content of Track has changed. Gets only raised for changes occurring after loading DC.Data with previously stored data.
    /// </summary>
    public event Action</*old*/Track, /*new*/Track>? HasChanged;
    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Track Constructor. If isStoring is true, adds Track to DC.Data.Tracks.
    /// </summary>
    public Track(
      string fileName, 
      string fullFileName, 
      string? title, 
      TimeSpan? duration, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? genres, 
      string? publisher, 
      int? year, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists, 
      bool isStoring = true)
    {
      Key = StorageExtensions.NoKey;
      FileName = fileName;
      FullFileName = fullFileName;
      Title = title;
      Duration = duration.Round(Rounding.Seconds);
      Album = album;
      AlbumTrack = albumTrack;
      Artists = artists;
      Composers = composers;
      Genres = genres;
      Publisher = publisher;
      Year = year;
      Weight = weight;
      Volume = volume;
      SkipStart = skipStart;
      SkipEnd = skipEnd;
      TitleArtists = titleArtists;
      onConstruct();
      if (DC.Data.IsTransaction) {
        DC.Data.AddTransaction(new TransactionItem(0,TransactionActivityEnum.New, Key, this));
      }

      if (isStoring) {
        Store();
      }
    }
    partial void onConstruct();


    /// <summary>
    /// Cloning constructor. It will copy all data from original except any collection (children).
    /// </summary>
    #pragma warning disable CS8618 // Children collections are uninitialized.
    public Track(Track original) {
    #pragma warning restore CS8618 //
      Key = StorageExtensions.NoKey;
      FileName = original.FileName;
      FullFileName = original.FullFileName;
      Title = original.Title;
      Duration = original.Duration;
      Album = original.Album;
      AlbumTrack = original.AlbumTrack;
      Artists = original.Artists;
      Composers = original.Composers;
      Genres = original.Genres;
      Publisher = original.Publisher;
      Year = original.Year;
      Weight = original.Weight;
      Volume = original.Volume;
      SkipStart = original.SkipStart;
      SkipEnd = original.SkipEnd;
      TitleArtists = original.TitleArtists;
      onCloned(this);
    }
    partial void onCloned(Track clone);


    /// <summary>
    /// Constructor for Track read from CSV file
    /// </summary>
    private Track(int key, CsvReader csvReader){
      Key = key;
      FileName = csvReader.ReadString();
      FullFileName = csvReader.ReadString();
      Title = csvReader.ReadStringNull();
      Duration = csvReader.ReadTimeNull();
      Album = csvReader.ReadStringNull();
      AlbumTrack = csvReader.ReadIntNull();
      Artists = csvReader.ReadStringNull();
      Composers = csvReader.ReadStringNull();
      Genres = csvReader.ReadStringNull();
      Publisher = csvReader.ReadStringNull();
      Year = csvReader.ReadIntNull();
      Weight = csvReader.ReadIntNull();
      Volume = csvReader.ReadIntNull();
      SkipStart = csvReader.ReadIntNull();
      SkipEnd = csvReader.ReadIntNull();
      TitleArtists = csvReader.ReadString();
      DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
      onCsvConstruct();
    }
    partial void onCsvConstruct();


    /// <summary>
    /// New Track read from CSV file
    /// </summary>
    internal static Track Create(int key, CsvReader csvReader) {
      return new Track(key, csvReader);
    }
    #endregion


    #region Methods
    //      -------

    /// <summary>
    /// Adds Track to DC.Data.Tracks.<br/>
    /// Throws an Exception when Track is already stored.
    /// </summary>
    public void Store() {
      if (Key>=0) {
        throw new Exception($"Track cannot be stored again in DC.Data, key {Key} is greater equal 0." + Environment.NewLine + ToString());
      }

      var isCancelled = false;
      onStoring(ref isCancelled);
      if (isCancelled) return;

      DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
      DC.Data.Tracks.Add(this);
      onStored();
    }
    partial void onStoring(ref bool isCancelled);
    partial void onStored();


    /// <summary>
    /// Estimated number of UTF8 characters needed to write Track to CSV file
    /// </summary>
    public const int EstimatedLineLength = 1425;


    /// <summary>
    /// Write Track to CSV file
    /// </summary>
    internal static void Write(Track track, CsvWriter csvWriter) {
      track.onCsvWrite();
      csvWriter.Write(track.FileName);
      csvWriter.Write(track.FullFileName);
      csvWriter.Write(track.Title);
      csvWriter.WriteTime(track.Duration);
      csvWriter.Write(track.Album);
      csvWriter.Write(track.AlbumTrack);
      csvWriter.Write(track.Artists);
      csvWriter.Write(track.Composers);
      csvWriter.Write(track.Genres);
      csvWriter.Write(track.Publisher);
      csvWriter.Write(track.Year);
      csvWriter.Write(track.Weight);
      csvWriter.Write(track.Volume);
      csvWriter.Write(track.SkipStart);
      csvWriter.Write(track.SkipEnd);
      csvWriter.Write(track.TitleArtists);
    }
    partial void onCsvWrite();


    /// <summary>
    /// Updates Track with the provided values
    /// </summary>
    public void Update(
      string? title, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? genres, 
      string? publisher, 
      int? year, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists)
    {
      var clone = new Track(this);
      var isCancelled = false;
      onUpdating(
        title, 
        album, 
        albumTrack, 
        artists, 
        composers, 
        genres, 
        publisher, 
        year, 
        weight, 
        volume, 
        skipStart, 
        skipEnd, 
        titleArtists, 
        ref isCancelled);
      if (isCancelled) return;

      var isChangeDetected = false;
      if (Title!=title) {
        Title = title;
        isChangeDetected = true;
      }
      if (Album!=album) {
        Album = album;
        isChangeDetected = true;
      }
      if (AlbumTrack!=albumTrack) {
        AlbumTrack = albumTrack;
        isChangeDetected = true;
      }
      if (Artists!=artists) {
        Artists = artists;
        isChangeDetected = true;
      }
      if (Composers!=composers) {
        Composers = composers;
        isChangeDetected = true;
      }
      if (Genres!=genres) {
        Genres = genres;
        isChangeDetected = true;
      }
      if (Publisher!=publisher) {
        Publisher = publisher;
        isChangeDetected = true;
      }
      if (Year!=year) {
        Year = year;
        isChangeDetected = true;
      }
      if (Weight!=weight) {
        Weight = weight;
        isChangeDetected = true;
      }
      if (Volume!=volume) {
        Volume = volume;
        isChangeDetected = true;
      }
      if (SkipStart!=skipStart) {
        SkipStart = skipStart;
        isChangeDetected = true;
      }
      if (SkipEnd!=skipEnd) {
        SkipEnd = skipEnd;
        isChangeDetected = true;
      }
      if (TitleArtists!=titleArtists) {
        if (Key>=0) {
            DC.Data._TracksByTitleArtists.Remove(TitleArtists);
        }
        TitleArtists = titleArtists;
        if (Key>=0) {
            DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
        }
        isChangeDetected = true;
      }
      if (isChangeDetected) {
        onUpdated(clone);
        if (Key>=0) {
          DC.Data.Tracks.ItemHasChanged(clone, this);
        } else if (DC.Data.IsTransaction) {
          DC.Data.AddTransaction(new TransactionItem(0, TransactionActivityEnum.Update, Key, this, oldItem: clone));
        }
        HasChanged?.Invoke(clone, this);
      }
    }
    partial void onUpdating(
      string? title, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? genres, 
      string? publisher, 
      int? year, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists, 
      ref bool isCancelled);
    partial void onUpdated(Track old);


    /// <summary>
    /// Updates this Track with values from CSV file
    /// </summary>
    internal static void Update(Track track, CsvReader csvReader){
      var fileName = csvReader.ReadString();
      if (track.FileName!=fileName) {
        throw new Exception($"Track.Update(): Property FileName '{track.FileName}' is " +
          $"readonly, fileName '{fileName}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }
      var fullFileName = csvReader.ReadString();
      if (track.FullFileName!=fullFileName) {
        throw new Exception($"Track.Update(): Property FullFileName '{track.FullFileName}' is " +
          $"readonly, fullFileName '{fullFileName}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }
      track.Title = csvReader.ReadStringNull();
      var duration = csvReader.ReadTimeNull();
      if (track.Duration!=duration) {
        throw new Exception($"Track.Update(): Property Duration '{track.Duration}' is " +
          $"readonly, duration '{duration}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }
      track.Album = csvReader.ReadStringNull();
      track.AlbumTrack = csvReader.ReadIntNull();
      track.Artists = csvReader.ReadStringNull();
      track.Composers = csvReader.ReadStringNull();
      track.Genres = csvReader.ReadStringNull();
      track.Publisher = csvReader.ReadStringNull();
      track.Year = csvReader.ReadIntNull();
      track.Weight = csvReader.ReadIntNull();
      track.Volume = csvReader.ReadIntNull();
      track.SkipStart = csvReader.ReadIntNull();
      track.SkipEnd = csvReader.ReadIntNull();
      DC.Data._TracksByTitleArtists.Remove(track.TitleArtists);
      track.TitleArtists = csvReader.ReadString();
      DC.Data._TracksByTitleArtists.Add(track.TitleArtists, track);
      track.onCsvUpdate();
    }
    partial void onCsvUpdate();


    /// <summary>
    /// Removes Track from DC.Data.Tracks.
    /// </summary>
    public void Release() {
      if (Key<0) {
        throw new Exception($"Track.Release(): Track '{this}' is not stored in DC.Data, key is {Key}.");
      }
      DC.Data._TracksByTitleArtists.Remove(TitleArtists);
      onReleased();
      DC.Data.Tracks.Remove(Key);
    }
    partial void onReleased();


    /// <summary>
    /// Undoes the new() statement as part of a transaction rollback.
    /// </summary>
    internal static void RollbackItemNew(IStorageItem item) {
      var track = (Track) item;
      track.onRollbackItemNew();
    }
    partial void onRollbackItemNew();


    /// <summary>
    /// Releases Track from DC.Data.Tracks as part of a transaction rollback of Store().
    /// </summary>
    internal static void RollbackItemStore(IStorageItem item) {
      var track = (Track) item;
      DC.Data._TracksByTitleArtists.Remove(track.TitleArtists);
      track.onRollbackItemStored();
    }
    partial void onRollbackItemStored();


    /// <summary>
    /// Restores the Track item data as it was before the last update as part of a transaction rollback.
    /// </summary>
    internal static void RollbackItemUpdate(IStorageItem oldStorageItem, IStorageItem newStorageItem) {
      var oldItem = (Track) oldStorageItem;
      var newItem = (Track) newStorageItem;
      if (newItem.FileName!=oldItem.FileName) {
        throw new Exception($"Track.Update(): Property FileName '{newItem.FileName}' is " +
          $"readonly, FileName '{oldItem.FileName}' read from the CSV file should be the same." + Environment.NewLine + 
          newItem.ToString());
      }
      if (newItem.FullFileName!=oldItem.FullFileName) {
        throw new Exception($"Track.Update(): Property FullFileName '{newItem.FullFileName}' is " +
          $"readonly, FullFileName '{oldItem.FullFileName}' read from the CSV file should be the same." + Environment.NewLine + 
          newItem.ToString());
      }
      newItem.Title = oldItem.Title;
      if (newItem.Duration!=oldItem.Duration) {
        throw new Exception($"Track.Update(): Property Duration '{newItem.Duration}' is " +
          $"readonly, Duration '{oldItem.Duration}' read from the CSV file should be the same." + Environment.NewLine + 
          newItem.ToString());
      }
      newItem.Album = oldItem.Album;
      newItem.AlbumTrack = oldItem.AlbumTrack;
      newItem.Artists = oldItem.Artists;
      newItem.Composers = oldItem.Composers;
      newItem.Genres = oldItem.Genres;
      newItem.Publisher = oldItem.Publisher;
      newItem.Year = oldItem.Year;
      newItem.Weight = oldItem.Weight;
      newItem.Volume = oldItem.Volume;
      newItem.SkipStart = oldItem.SkipStart;
      newItem.SkipEnd = oldItem.SkipEnd;
      DC.Data._TracksByTitleArtists.Remove(newItem.TitleArtists);
      newItem.TitleArtists = oldItem.TitleArtists;
      DC.Data._TracksByTitleArtists.Add(newItem.TitleArtists, newItem);
      newItem.onRollbackItemUpdated(oldItem);
    }
    partial void onRollbackItemUpdated(Track oldTrack);


    /// <summary>
    /// Adds Track to DC.Data.Tracks as part of a transaction rollback of Release().
    /// </summary>
    internal static void RollbackItemRelease(IStorageItem item) {
      var track = (Track) item;
      DC.Data._TracksByTitleArtists.Add(track.TitleArtists, track);
      track.onRollbackItemRelease();
    }
    partial void onRollbackItemRelease();


    /// <summary>
    /// Returns property values for tracing. Parents are shown with their key instead their content.
    /// </summary>
    public string ToTraceString() {
      var returnString =
        $"{this.GetKeyOrHash()}|" +
        $" {FileName}|" +
        $" {FullFileName}|" +
        $" {Title}|" +
        $" {Duration}|" +
        $" {Album}|" +
        $" {AlbumTrack}|" +
        $" {Artists}|" +
        $" {Composers}|" +
        $" {Genres}|" +
        $" {Publisher}|" +
        $" {Year}|" +
        $" {Weight}|" +
        $" {Volume}|" +
        $" {SkipStart}|" +
        $" {SkipEnd}|" +
        $" {TitleArtists}";
      onToTraceString(ref returnString);
      return returnString;
    }
    partial void onToTraceString(ref string returnString);


    /// <summary>
    /// Returns property values
    /// </summary>
    public string ToShortString() {
      var returnString =
        $"{Key.ToKeyString()}," +
        $" {FileName}," +
        $" {FullFileName}," +
        $" {Title}," +
        $" {Duration}," +
        $" {Album}," +
        $" {AlbumTrack}," +
        $" {Artists}," +
        $" {Composers}," +
        $" {Genres}," +
        $" {Publisher}," +
        $" {Year}," +
        $" {Weight}," +
        $" {Volume}," +
        $" {SkipStart}," +
        $" {SkipEnd}," +
        $" {TitleArtists}";
      onToShortString(ref returnString);
      return returnString;
    }
    partial void onToShortString(ref string returnString);


    /// <summary>
    /// Returns all property names and values
    /// </summary>
    public override string ToString() {
      var returnString =
        $"Key: {Key.ToKeyString()}," +
        $" FileName: {FileName}," +
        $" FullFileName: {FullFileName}," +
        $" Title: {Title}," +
        $" Duration: {Duration}," +
        $" Album: {Album}," +
        $" AlbumTrack: {AlbumTrack}," +
        $" Artists: {Artists}," +
        $" Composers: {Composers}," +
        $" Genres: {Genres}," +
        $" Publisher: {Publisher}," +
        $" Year: {Year}," +
        $" Weight: {Weight}," +
        $" Volume: {Volume}," +
        $" SkipStart: {SkipStart}," +
        $" SkipEnd: {SkipEnd}," +
        $" TitleArtists: {TitleArtists};";
      onToString(ref returnString);
      return returnString;
    }
    partial void onToString(ref string returnString);
    #endregion
  }
}
