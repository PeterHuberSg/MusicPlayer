//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into Track.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using StorageLib;


namespace MusicPlayer  {


  public partial class Track: IStorageItem<Track> {

    #region Properties
    //      ----------

    /// <summary>
    /// Unique identifier for Track. Gets set once Track gets added to DC.Data.
    /// </summary>
    public int Key { get; private set; }
    internal static void SetKey(IStorageItem track, int key, bool _) {
      ((Track)track).Key = key;
    }


    public string FileName { get; }


    public string FullFileName { get; }


    public Location Location { get; }


    public string? Title { get; private set; }


    public string? TitleLowerCase { get; private set; }


    /// <summary>
    /// Stores less than 24 hours with second precision.
    ///  </summary>
    public TimeSpan? Duration { get; }


    public string? Album { get; private set; }


    public string? AlbumLowerCase { get; private set; }


    public int? AlbumTrack { get; private set; }


    public string? Artists { get; private set; }


    public string? ArtistsLowerCase { get; private set; }


    public string? Composers { get; private set; }


    public string? ComposersLowerCase { get; private set; }


    public string? Publisher { get; private set; }


    public string? PublisherLowerCase { get; private set; }


    public int? Year { get; private set; }


    public string? Genres { get; private set; }


    public int? Weight { get; private set; }


    public int? Volume { get; private set; }


    public int? SkipStart { get; private set; }


    public int? SkipEnd { get; private set; }


    public string TitleArtists { get; private set; }


    public IStorageReadOnlyList<PlaylistTrack> PlaylistTracks => playlistTracks;
    readonly StorageList<PlaylistTrack> playlistTracks;


    /// <summary>
    /// Headers written to first line in CSV file
    /// </summary>
    internal static readonly string[] Headers = {
      "Key", 
      "FileName", 
      "FullFileName", 
      "Location", 
      "Title", 
      "Duration", 
      "Album", 
      "AlbumTrack", 
      "Artists", 
      "Composers", 
      "Publisher", 
      "Year", 
      "Genres", 
      "Weight", 
      "Volume", 
      "SkipStart", 
      "SkipEnd", 
      "TitleArtists"
    };


    /// <summary>
    /// None existing Track, used as a temporary place holder when reading a CSV file
    /// which was not compacted. It might create first a later deleted item linking to a 
    /// deleted parent. In this case, the parent property gets set to NoTrack. Once the CSV
    /// file is completely read, that child will actually be deleted (released) and Verify()
    /// ensures that there are no stored children with links to NoTrack.
    /// </summary>
    internal static Track NoTrack = new Track("NoFileName", "NoFullFileName", Location.NoLocation, null, null, null, null, null, null, null, null, null, null, null, null, null, "NoTitleArtists", isStoring: false);
    #endregion


    #region Events
    //      ------

    /// <summary>
    /// Content of Track has changed. Gets only raised for changes occurring after loading DC.Data with previously stored data.
    /// </summary>
    public event Action</*old*/Track, /*new*/Track>? HasChanged;
    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Track Constructor. If isStoring is true, adds Track to DC.Data.Tracks.
    /// </summary>
    public Track(
      string fileName, 
      string fullFileName, 
      Location location, 
      string? title, 
      TimeSpan? duration, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? publisher, 
      int? year, 
      string? genres, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists, 
      bool isStoring = true)
    {
      Key = StorageExtensions.NoKey;
      FileName = fileName;
      FullFileName = fullFileName;
      Location = location;
      Title = title;
      TitleLowerCase = Title?.ToLowerInvariant();
      Duration = duration.Round(Rounding.Seconds);
      Album = album;
      AlbumLowerCase = Album?.ToLowerInvariant();
      AlbumTrack = albumTrack;
      Artists = artists;
      ArtistsLowerCase = Artists?.ToLowerInvariant();
      Composers = composers;
      ComposersLowerCase = Composers?.ToLowerInvariant();
      Publisher = publisher;
      PublisherLowerCase = Publisher?.ToLowerInvariant();
      Year = year;
      Genres = genres;
      Weight = weight;
      Volume = volume;
      SkipStart = skipStart;
      SkipEnd = skipEnd;
      TitleArtists = titleArtists;
      playlistTracks = new StorageList<PlaylistTrack>();
      Location.AddToTracks(this);
      onConstruct();
      if (DC.Data?.IsTransaction??false) {
        DC.Data.AddTransaction(new TransactionItem(1,TransactionActivityEnum.New, Key, this));
      }

      if (isStoring) {
        Store();
      }
    }
    partial void onConstruct();


    /// <summary>
    /// Cloning constructor. It will copy all data from original except any collection (children).
    /// </summary>
    #pragma warning disable CS8618 // Children collections are uninitialized.
    public Track(Track original) {
    #pragma warning restore CS8618 //
      Key = StorageExtensions.NoKey;
      FileName = original.FileName;
      FullFileName = original.FullFileName;
      Location = original.Location;
      Title = original.Title;
      TitleLowerCase = original.TitleLowerCase;
      Duration = original.Duration;
      Album = original.Album;
      AlbumLowerCase = original.AlbumLowerCase;
      AlbumTrack = original.AlbumTrack;
      Artists = original.Artists;
      ArtistsLowerCase = original.ArtistsLowerCase;
      Composers = original.Composers;
      ComposersLowerCase = original.ComposersLowerCase;
      Publisher = original.Publisher;
      PublisherLowerCase = original.PublisherLowerCase;
      Year = original.Year;
      Genres = original.Genres;
      Weight = original.Weight;
      Volume = original.Volume;
      SkipStart = original.SkipStart;
      SkipEnd = original.SkipEnd;
      TitleArtists = original.TitleArtists;
      onCloned(this);
    }
    partial void onCloned(Track clone);


    /// <summary>
    /// Constructor for Track read from CSV file
    /// </summary>
    private Track(int key, CsvReader csvReader, DataStoreCSV<Track> dataStore){
      Key = key;
      FileName = csvReader.ReadString();
      FullFileName = csvReader.ReadString();
      var locationKey = csvReader.ReadInt();
      Location = DC.Data._Locations.GetItem(locationKey)?? Location.NoLocation;
      Title = csvReader.ReadStringNull();
      TitleLowerCase = Title?.ToLowerInvariant();
      Duration = csvReader.ReadTimeNull();
      Album = csvReader.ReadStringNull();
      AlbumLowerCase = Album?.ToLowerInvariant();
      AlbumTrack = csvReader.ReadIntNull();
      Artists = csvReader.ReadStringNull();
      ArtistsLowerCase = Artists?.ToLowerInvariant();
      Composers = csvReader.ReadStringNull();
      ComposersLowerCase = Composers?.ToLowerInvariant();
      Publisher = csvReader.ReadStringNull();
      PublisherLowerCase = Publisher?.ToLowerInvariant();
      Year = csvReader.ReadIntNull();
      Genres = csvReader.ReadStringNull();
      Weight = csvReader.ReadIntNull();
      Volume = csvReader.ReadIntNull();
      SkipStart = csvReader.ReadIntNull();
      SkipEnd = csvReader.ReadIntNull();
      TitleArtists = csvReader.ReadString();
      DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
      playlistTracks = new StorageList<PlaylistTrack>();
      if (Location!=Location.NoLocation) {
        Location.AddToTracks(this);
      }
      onCsvConstruct();
    }
    partial void onCsvConstruct();


    /// <summary>
    /// New Track read from CSV file
    /// </summary>
    internal static Track Create(int key, CsvReader csvReader, DataStoreCSV<Track> dataStore) {
      return new Track(key, csvReader, dataStore);
    }


    /// <summary>
    /// Verify that track.Location exists.
    /// </summary>
    internal static bool Verify(Track track) {
      if (track.Location==Location.NoLocation) return false;
      return true;
    }
    #endregion


    #region Methods
    //      -------

    /// <summary>
    /// Adds Track to DC.Data.Tracks.<br/>
    /// Throws an Exception when Track is already stored.<br/>
    /// Returns true unless onStoring() cancels storing.
    /// </summary>
    public bool Store() {
      if (Key>=0) {
        throw new Exception($"Track cannot be stored again in DC.Data, key {Key} is greater equal 0." + Environment.NewLine + ToString());
      }

      var isCancelled = false;
      onStoring(ref isCancelled);
      if (isCancelled) return false;

      if (Location.Key<0) {
        throw new Exception($"Cannot store child Track '{this}'.Location to Location '{Location}' because parent is not stored yet.");
      }
      DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
      DC.Data._Tracks.Add(this);
      onStored();
      return true;
    }
    partial void onStoring(ref bool isCancelled);
    partial void onStored();


    /// <summary>
    /// Estimated number of UTF8 characters needed to write Track to CSV file
    /// </summary>
    public const int EstimatedLineLength = 1425;


    /// <summary>
    /// Write Track to CSV file
    /// </summary>
    internal static void Write(Track track, CsvWriter csvWriter) {
      track.onCsvWrite();
      csvWriter.Write(track.FileName);
      csvWriter.Write(track.FullFileName);
      if (track.Location.Key<0) throw new Exception($"Cannot write track '{track}' to CSV File, because Location is not stored in DC.Data.Locations.");

      csvWriter.Write(track.Location.Key.ToString());
      csvWriter.Write(track.Title);
      csvWriter.WriteTime(track.Duration);
      csvWriter.Write(track.Album);
      csvWriter.Write(track.AlbumTrack);
      csvWriter.Write(track.Artists);
      csvWriter.Write(track.Composers);
      csvWriter.Write(track.Publisher);
      csvWriter.Write(track.Year);
      csvWriter.Write(track.Genres);
      csvWriter.Write(track.Weight);
      csvWriter.Write(track.Volume);
      csvWriter.Write(track.SkipStart);
      csvWriter.Write(track.SkipEnd);
      csvWriter.Write(track.TitleArtists);
    }
    partial void onCsvWrite();


    /// <summary>
    /// Updates Track with the provided values.<br/>
    /// Returns true unless onUpdating() cancels updating.
    /// </summary>
    public bool Update(
      string? title, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? publisher, 
      int? year, 
      string? genres, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists)
    {
      var clone = new Track(this);
      var isCancelled = false;
      onUpdating(
        title, 
        album, 
        albumTrack, 
        artists, 
        composers, 
        publisher, 
        year, 
        genres, 
        weight, 
        volume, 
        skipStart, 
        skipEnd, 
        titleArtists, 
        ref isCancelled);
      if (isCancelled) return false;


      //update properties and detect if any value has changed
      var isChangeDetected = false;
      if (Title!=title) {
        Title = title;
        TitleLowerCase = Title?.ToLowerInvariant();
        isChangeDetected = true;
      }
      if (Album!=album) {
        Album = album;
        AlbumLowerCase = Album?.ToLowerInvariant();
        isChangeDetected = true;
      }
      if (AlbumTrack!=albumTrack) {
        AlbumTrack = albumTrack;
        isChangeDetected = true;
      }
      if (Artists!=artists) {
        Artists = artists;
        ArtistsLowerCase = Artists?.ToLowerInvariant();
        isChangeDetected = true;
      }
      if (Composers!=composers) {
        Composers = composers;
        ComposersLowerCase = Composers?.ToLowerInvariant();
        isChangeDetected = true;
      }
      if (Publisher!=publisher) {
        Publisher = publisher;
        PublisherLowerCase = Publisher?.ToLowerInvariant();
        isChangeDetected = true;
      }
      if (Year!=year) {
        Year = year;
        isChangeDetected = true;
      }
      if (Genres!=genres) {
        Genres = genres;
        isChangeDetected = true;
      }
      if (Weight!=weight) {
        Weight = weight;
        isChangeDetected = true;
      }
      if (Volume!=volume) {
        Volume = volume;
        isChangeDetected = true;
      }
      if (SkipStart!=skipStart) {
        SkipStart = skipStart;
        isChangeDetected = true;
      }
      if (SkipEnd!=skipEnd) {
        SkipEnd = skipEnd;
        isChangeDetected = true;
      }
      if (TitleArtists!=titleArtists) {
        if (Key>=0) {
            DC.Data._TracksByTitleArtists.Remove(TitleArtists);
        }
        TitleArtists = titleArtists;
        if (Key>=0) {
         DC.Data._TracksByTitleArtists.Add(TitleArtists, this);
        }
        isChangeDetected = true;
      }
      if (isChangeDetected) {
        onUpdated(clone);
        if (Key>=0) {
          DC.Data._Tracks.ItemHasChanged(clone, this);
        } else if (DC.Data.IsTransaction) {
          DC.Data.AddTransaction(new TransactionItem(1, TransactionActivityEnum.Update, Key, this, oldItem: clone));
        }
        HasChanged?.Invoke(clone, this);
      }
    return true;
    }
    partial void onUpdating(
      string? title, 
      string? album, 
      int? albumTrack, 
      string? artists, 
      string? composers, 
      string? publisher, 
      int? year, 
      string? genres, 
      int? weight, 
      int? volume, 
      int? skipStart, 
      int? skipEnd, 
      string titleArtists, 
      ref bool isCancelled);
    partial void onUpdated(Track old);


    /// <summary>
    /// Updates this Track with values from CSV file
    /// </summary>
    internal static void Update(Track track, CsvReader csvReader, DataStoreCSV<Track> dataStore){
      //read first all property values into local variables
      var fileName = csvReader.ReadString();
      if (track.FileName!=fileName) {
        throw new Exception($"Track.Update(): Property FileName '{track.FileName}' is " +
          $"readonly, fileName '{fileName}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }

      var fullFileName = csvReader.ReadString();
      if (track.FullFileName!=fullFileName) {
        throw new Exception($"Track.Update(): Property FullFileName '{track.FullFileName}' is " +
          $"readonly, fullFileName '{fullFileName}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }

      var location = DC.Data._Locations.GetItem(csvReader.ReadInt())??Location.NoLocation;
      if (track.Location!=location) {
        throw new Exception($"Track.Update(): Property Location '{track.Location}' is " +
          $"readonly, location '{location}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }

      var title = csvReader.ReadStringNull();

      var duration = csvReader.ReadTimeNull();
      if (track.Duration!=duration) {
        throw new Exception($"Track.Update(): Property Duration '{track.Duration}' is " +
          $"readonly, duration '{duration}' read from the CSV file should be the same." + Environment.NewLine + 
          track.ToString());
      }

      var album = csvReader.ReadStringNull();

      var albumTrack = csvReader.ReadIntNull();

      var artists = csvReader.ReadStringNull();

      var composers = csvReader.ReadStringNull();

      var publisher = csvReader.ReadStringNull();

      var year = csvReader.ReadIntNull();

      var genres = csvReader.ReadStringNull();

      var weight = csvReader.ReadIntNull();

      var volume = csvReader.ReadIntNull();

      var skipStart = csvReader.ReadIntNull();

      var skipEnd = csvReader.ReadIntNull();

      var titleArtists = csvReader.ReadString();


      //update not readonly properties
      track.Title = title;
      track.Album = album;
      track.AlbumTrack = albumTrack;
      track.Artists = artists;
      track.Composers = composers;
      track.Publisher = publisher;
      track.Year = year;
      track.Genres = genres;
      track.Weight = weight;
      track.Volume = volume;
      track.SkipStart = skipStart;
      track.SkipEnd = skipEnd;
      if (track.TitleArtists!=titleArtists) {
        DC.Data._TracksByTitleArtists.Remove(track.TitleArtists);
        track.TitleArtists = titleArtists;
        DC.Data._TracksByTitleArtists.Add(track.TitleArtists, track);
      }
      track.onCsvUpdate();
    }
    partial void onCsvUpdate();


    /// <summary>
    /// Add playlistTrack to PlaylistTracks.
    /// </summary>
    internal void AddToPlaylistTracks(PlaylistTrack playlistTrack) {
#if DEBUG
      if (playlistTrack==PlaylistTrack.NoPlaylistTrack) throw new Exception();
      if ((playlistTrack.Key>=0)&&(Key<0)) throw new Exception();
      if (playlistTracks.Contains(playlistTrack)) throw new Exception();
#endif
      playlistTracks.Add(playlistTrack);
      onAddedToPlaylistTracks(playlistTrack);
    }
    partial void onAddedToPlaylistTracks(PlaylistTrack playlistTrack);


    /// <summary>
    /// Removes playlistTrack from Track.
    /// </summary>
    internal void RemoveFromPlaylistTracks(PlaylistTrack playlistTrack) {
#if DEBUG
      if (!playlistTracks.Remove(playlistTrack)) throw new Exception();
#else
        playlistTracks.Remove(playlistTrack);
#endif
      onRemovedFromPlaylistTracks(playlistTrack);
    }
    partial void onRemovedFromPlaylistTracks(PlaylistTrack playlistTrack);


    /// <summary>
    /// Removes Track from DC.Data.Tracks.
    /// </summary>
    public void Release() {
      if (Key<0) {
        throw new Exception($"Track.Release(): Track '{this}' is not stored in DC.Data, key is {Key}.");
      }
      onReleasing();
      foreach (var playlistTrack in PlaylistTracks) {
        if (playlistTrack?.Key>=0) {
          throw new Exception($"Cannot release Track '{this}' " + Environment.NewLine + 
            $"because '{playlistTrack}' in Track.PlaylistTracks is still stored.");
        }
      }
      DC.Data._TracksByTitleArtists.Remove(TitleArtists);
      DC.Data._Tracks.Remove(Key);
      onReleased();
    }
    partial void onReleasing();
    partial void onReleased();


    /// <summary>
    /// Disconnects Track from parents and possibly from dictionaries in DC.Data.
    /// </summary>
    internal static void Disconnect(Track track){
      if (track.Location!=Location.NoLocation) {
        track.Location.RemoveFromTracks(track);
      }
      DC.Data._TracksByTitleArtists.Remove(track.TitleArtists);
      track.onDisconnected();
    }
    partial void onDisconnected();


    /// <summary>
    /// Removes Track from parents as part of a transaction rollback of the new() statement.
    /// </summary>
    internal static void RollbackItemNew(IStorageItem item) {
      var track = (Track) item;
      if (track.Location!=Location.NoLocation) {
        track.Location.RemoveFromTracks(track);
      }
      track.onRollbackItemNew();
    }
    partial void onRollbackItemNew();


    /// <summary>
    /// Releases Track from DC.Data.Tracks as part of a transaction rollback of Store().
    /// </summary>
    internal static void RollbackItemStore(IStorageItem item) {
      var track = (Track) item;
      DC.Data._TracksByTitleArtists.Remove(track.TitleArtists);
      track.onRollbackItemStored();
    }
    partial void onRollbackItemStored();


    /// <summary>
    /// Restores the Track item data as it was before the last update as part of a transaction rollback.
    /// </summary>
    internal static void RollbackItemUpdate(IStorageItem oldStorageItem, IStorageItem newStorageItem) {
      var oldItem = (Track) oldStorageItem;//an item clone with the values before item was updated
      var item = (Track) newStorageItem;//is the instance whose values should be restored

      // if possible, throw exceptions before changing anything
      if (item.FileName!=oldItem.FileName) {
        throw new Exception($"Track.Update(): Property FileName '{item.FileName}' is " +
          $"readonly, FileName '{oldItem.FileName}' should be the same." + Environment.NewLine + 
          item.ToString());
      }
      if (item.FullFileName!=oldItem.FullFileName) {
        throw new Exception($"Track.Update(): Property FullFileName '{item.FullFileName}' is " +
          $"readonly, FullFileName '{oldItem.FullFileName}' should be the same." + Environment.NewLine + 
          item.ToString());
      }
      if (item.Location!=oldItem.Location) {
        throw new Exception($"Track.Update(): Property Location '{item.Location}' is " +
          $"readonly, Location '{oldItem.Location}' should be the same." + Environment.NewLine + 
          item.ToString());
      }
      if (item.Duration!=oldItem.Duration) {
        throw new Exception($"Track.Update(): Property Duration '{item.Duration}' is " +
          $"readonly, Duration '{oldItem.Duration}' should be the same." + Environment.NewLine + 
          item.ToString());
      }

      // remove updated item from dictionaries
      DC.Data._TracksByTitleArtists.Remove(item.TitleArtists);

      // updated item: restore old values
      item.Title = oldItem.Title;
      item.TitleLowerCase = item.Title?.ToLowerInvariant();
      item.Album = oldItem.Album;
      item.AlbumLowerCase = item.Album?.ToLowerInvariant();
      item.AlbumTrack = oldItem.AlbumTrack;
      item.Artists = oldItem.Artists;
      item.ArtistsLowerCase = item.Artists?.ToLowerInvariant();
      item.Composers = oldItem.Composers;
      item.ComposersLowerCase = item.Composers?.ToLowerInvariant();
      item.Publisher = oldItem.Publisher;
      item.PublisherLowerCase = item.Publisher?.ToLowerInvariant();
      item.Year = oldItem.Year;
      item.Genres = oldItem.Genres;
      item.Weight = oldItem.Weight;
      item.Volume = oldItem.Volume;
      item.SkipStart = oldItem.SkipStart;
      item.SkipEnd = oldItem.SkipEnd;
      item.TitleArtists = oldItem.TitleArtists;

      // add item with previous values to dictionaries
      DC.Data._TracksByTitleArtists.Add(item.TitleArtists, item);
      item.onRollbackItemUpdated(oldItem);
    }
    partial void onRollbackItemUpdated(Track oldTrack);


    /// <summary>
    /// Adds Track to DC.Data.Tracks as part of a transaction rollback of Release().
    /// </summary>
    internal static void RollbackItemRelease(IStorageItem item) {
      var track = (Track) item;
      DC.Data._TracksByTitleArtists.Add(track.TitleArtists, track);
      track.onRollbackItemRelease();
    }
    partial void onRollbackItemRelease();


    /// <summary>
    /// Returns property values for tracing. Parents are shown with their key instead their content.
    /// </summary>
    public string ToTraceString() {
      var returnString =
        $"{this.GetKeyOrHash()}|" +
        $" {FileName}|" +
        $" {FullFileName}|" +
        $" Location {Location.GetKeyOrHash()}|" +
        $" {Title}|" +
        $" {TitleLowerCase}|" +
        $" {Duration}|" +
        $" {Album}|" +
        $" {AlbumLowerCase}|" +
        $" {AlbumTrack}|" +
        $" {Artists}|" +
        $" {ArtistsLowerCase}|" +
        $" {Composers}|" +
        $" {ComposersLowerCase}|" +
        $" {Publisher}|" +
        $" {PublisherLowerCase}|" +
        $" {Year}|" +
        $" {Genres}|" +
        $" {Weight}|" +
        $" {Volume}|" +
        $" {SkipStart}|" +
        $" {SkipEnd}|" +
        $" {TitleArtists}";
      onToTraceString(ref returnString);
      return returnString;
    }
    partial void onToTraceString(ref string returnString);


    /// <summary>
    /// Returns property values
    /// </summary>
    public string ToShortString() {
      var returnString =
        $"{Key.ToKeyString()}," +
        $" {FileName}," +
        $" {FullFileName}," +
        $" {Location.ToShortString()}," +
        $" {Title}," +
        $" {TitleLowerCase}," +
        $" {Duration}," +
        $" {Album}," +
        $" {AlbumLowerCase}," +
        $" {AlbumTrack}," +
        $" {Artists}," +
        $" {ArtistsLowerCase}," +
        $" {Composers}," +
        $" {ComposersLowerCase}," +
        $" {Publisher}," +
        $" {PublisherLowerCase}," +
        $" {Year}," +
        $" {Genres}," +
        $" {Weight}," +
        $" {Volume}," +
        $" {SkipStart}," +
        $" {SkipEnd}," +
        $" {TitleArtists}";
      onToShortString(ref returnString);
      return returnString;
    }
    partial void onToShortString(ref string returnString);


    /// <summary>
    /// Returns all property names and values
    /// </summary>
    public override string ToString() {
      var returnString =
        $"Key: {Key.ToKeyString()}," +
        $" FileName: {FileName}," +
        $" FullFileName: {FullFileName}," +
        $" Location: {Location.ToShortString()}," +
        $" Title: {Title}," +
        $" TitleLowerCase: {TitleLowerCase}," +
        $" Duration: {Duration}," +
        $" Album: {Album}," +
        $" AlbumLowerCase: {AlbumLowerCase}," +
        $" AlbumTrack: {AlbumTrack}," +
        $" Artists: {Artists}," +
        $" ArtistsLowerCase: {ArtistsLowerCase}," +
        $" Composers: {Composers}," +
        $" ComposersLowerCase: {ComposersLowerCase}," +
        $" Publisher: {Publisher}," +
        $" PublisherLowerCase: {PublisherLowerCase}," +
        $" Year: {Year}," +
        $" Genres: {Genres}," +
        $" Weight: {Weight}," +
        $" Volume: {Volume}," +
        $" SkipStart: {SkipStart}," +
        $" SkipEnd: {SkipEnd}," +
        $" TitleArtists: {TitleArtists}," +
        $" PlaylistTracks: {PlaylistTracks.Count}," +
        $" PlaylistTracksStored: {PlaylistTracks.CountStoredItems};";
      onToString(ref returnString);
      return returnString;
    }
    partial void onToString(ref string returnString);
    #endregion
  }
}
